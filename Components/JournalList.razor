@inject NavigationManager NavigationManager
@inject JournalEntryService JournalEntryService
@inject AuthStateService AuthStateService
@inject ToastService ToastService
@inject IJSRuntime JS

<div class="journal-list-container">
    <div class="journal-header">
        <div class="flex justify-between items-center mb-6">
            <h2 class="journal-title">My Journal</h2>
            <button class="new-entry-btn" @onclick="CreateNewEntry">
                <span class="text-lg">+</span>
                New Entry
            </button>
        </div>

    @if (loading)
    {
        <div class="loading-container">
            <div class="loading-spinner"></div>
            <p class="loading-text">Loading entries...</p>
        </div>
    }
    else if (isSearching)
    {
        <div class="loading-container">
            <div class="loading-spinner"></div>
            <p class="loading-text">Searching...</p>
        </div>
    }
    else if (paginatedEntries.TotalCount == 0)
    {
        <div class="empty-state">
            @if (!HasActiveFilters())
            {
                <div class="empty-state-icon">üìñ</div>
                <h3 class="empty-state-title">No journal entries yet</h3>
                <p class="empty-state-text">Start documenting your thoughts and experiences</p>
                <button class="empty-state-btn" @onclick="CreateNewEntry">Write Your First Entry</button>
            }
            else
            {
                <div class="empty-state-icon">üîç</div>
                <h3 class="empty-state-title">No results found</h3>
                <p class="empty-state-text">No entries match your search criteria</p>
                <div class="empty-state-buttons">
                    <button class="empty-state-btn" @onclick="ClearAllFilters">Clear All Filters</button>
                    <button class="empty-state-btn secondary" @onclick="GoBack">Go Back</button>
                </div>
            }
        </div>
    }
    else
    {
        <div class="search-filters-section">
            <div class="search-filters-header">
                <h3>Search & Filter</h3>
                <button class="toggle-filters-btn" @onclick="ToggleFilters">
                    @(showAdvancedFilters ? "Hide Filters" : "Show Filters")
                </button>
            </div>

            <!-- Basic Search -->
            <div class="search-filter-container">
                <div class="search-input-wrapper">
                    <input type="text" 
                           @bind="searchParams.SearchTerm" 
                           @oninput="HandleSearchInput" 
                           @onkeypress="HandleSearchKeyPress"
                           placeholder="Search by title, content, or tags..." 
                           class="search-input" />
                    <span class="search-icon">üîç</span>
                </div>
                
                <button class="search-btn" @onclick="PerformAdvancedSearch" disabled="@isSearching">
                    @(isSearching ? "Searching..." : "Search")
                </button>
                
                <button class="clear-search-btn" @onclick="ClearAllFilters">
                    Clear All
                </button>
            </div>

            <!-- Advanced Filters -->
            @if (showAdvancedFilters)
            {
                <div class="advanced-filters">
                    <!-- Date Range Filter -->
                    <div class="filter-group">
                        <h4>Date Range</h4>
                        <div class="date-range-container">
                            <div class="date-input-wrapper">
                                <label for="start-date">From:</label>
                                <input type="date" 
                                       id="start-date"
                                       @bind="searchParams.StartDate" 
                                       class="date-input" />
                            </div>
                            <div class="date-input-wrapper">
                                <label for="end-date">To:</label>
                                <input type="date" 
                                       id="end-date"
                                       @bind="searchParams.EndDate" 
                                       class="date-input" />
                            </div>
                        </div>
                    </div>

                    <!-- Mood Filter -->
                    <div class="filter-group">
                        <h4>Moods</h4>
                        <div class="mood-filters">
                            @foreach (var mood in availableMoods)
                            {
                                <label class="mood-checkbox">
                                    <input type="checkbox" 
                                           @onchange="() => ToggleMood(mood.Id)"
                                           checked="@IsMoodSelected(mood.Id)" />
                                    <span class="mood-checkbox-icon">@mood.Icon</span>
                                    <span class="mood-checkbox-label">@mood.Name</span>
                                </label>
                            }
                        </div>
                    </div>

                    <!-- Tags Filter -->
                    <div class="filter-group">
                        <h4>Tags</h4>
                        <div class="tags-filter">
                            <input type="text" 
                                   @bind="tagInput" 
                                   @onkeypress="HandleTagKeyPress"
                                   placeholder="Enter tags (comma separated)..." 
                                   class="tag-input" />
                            <button class="add-tag-btn" @onclick="AddTags">
                                Add Tags
                            </button>
                            @if (searchParams.Tags != null && searchParams.Tags.Any())
                            {
                                <div class="selected-tags">
                                    @foreach (var tag in searchParams.Tags)
                                    {
                                        <span class="tag-chip">
                                            @tag
                                            <button class="remove-tag" @onclick="() => RemoveTag(tag)">√ó</button>
                                        </span>
                                    }
                                </div>
                            }
                        </div>
                    </div>
                </div>
            }

            <!-- Active Filters Summary -->
            @if (HasActiveFilters())
            {
                <div class="active-filters-summary">
                    <strong>Active filters:</strong>
                    @if (!string.IsNullOrWhiteSpace(searchParams.SearchTerm))
                    {
                        <span class="filter-chip">Text: "@searchParams.SearchTerm"</span>
                    }
                    @if (searchParams.StartDate.HasValue || searchParams.EndDate.HasValue)
                    {
                        <span class="filter-chip">
                            Date: @(searchParams.StartDate?.ToString("MMM dd, yyyy") ?? "Any") - @(searchParams.EndDate?.ToString("MMM dd, yyyy") ?? "Any")
                        </span>
                    }
                    @if (searchParams.MoodIds?.Any() == true)
                    {
                        var selectedMoodNames = availableMoods
                            .Where(m => searchParams.MoodIds.Contains(m.Id))
                            .Select(m => m.Name);
                        <span class="filter-chip">Moods: @string.Join(", ", selectedMoodNames)</span>
                    }
                    @if (searchParams.Tags?.Any() == true)
                    {
                        <span class="filter-chip">Tags: @string.Join(", ", searchParams.Tags)</span>
                    }
                </div>
            }
        </div>

        <!-- Search Results Info -->
        @if (!isSearching)
        {
            <div class="search-results-info">
                Found @filteredEntries.Count() result@(filteredEntries.Count() != 1 ? "s" : "")
                @(HasActiveFilters() ? " with active filters" : "")
            </div>
        }

        <div class="journal-grid">
            @foreach (var entry in filteredEntries)
            {
                <div class="journal-entry-card" @key="entry.Id" @onclick="() => ViewEntry(entry.Id)">
                    <div class="journal-entry-header">
                        <h3 class="journal-entry-title">@entry.Title</h3>
                        <div class="journal-entry-date">@entry.EntryDate.ToString("MMM dd, yyyy")</div>
                    </div>
                    
                    <div class="journal-entry-preview">
                        @GetContentPreview(entry.Content)
                    </div>
                    
                    <div class="journal-entry-footer">
                        <div class="journal-entry-meta">
                            <!-- Mood display will be implemented later with the new mood system -->
                        </div>
                        <div class="journal-entry-updated">
                            Updated @entry.UpdatedAt.ToString("MMM d")
                        </div>
                    </div>
                    
                    <div class="journal-entry-actions">
                        <button class="action-btn edit" @onclick="() => EditEntry(entry.Id)" @onclick:stopPropagation title="Edit">
                            ‚úèÔ∏è
                        </button>
                        <button class="action-btn delete" @onclick="() => DeleteEntry(entry.Id)" @onclick:stopPropagation title="Delete">
                            üóëÔ∏è
                        </button>
                    </div>
                </div>
            }
        </div>

        <!-- Pagination Controls -->
        <div class="pagination-container">
            <div class="pagination-info">
                <span>Showing @((currentPage - 1) * pageSize + 1)-@(Math.Min(currentPage * pageSize, paginatedEntries.TotalCount)) of @paginatedEntries.TotalCount entries</span>
            </div>
            
            <div class="pagination-controls">
                <button type="button" class="pagination-btn" 
                        @onclick="PreviousPage"
                        disabled="@(currentPage <= 1)">
                    ‚Üê Previous
                </button>
                
                <div class="pagination-numbers">
    @for (int i = 1; i <= paginatedEntries.TotalPages; i++)
    {
        // FIX: Create a local variable to capture the CURRENT value of i
        int pageNumber = i; 

        @if (i == 1 || i == paginatedEntries.TotalPages || (i >= currentPage - 1 && i <= currentPage + 1))
        {
            <button type="button" 
                    class="pagination-number @(pageNumber == currentPage ? "active" : "")" 
                    @onclick="() => GoToPage(pageNumber)"
                    disabled="@(pageNumber == currentPage)">
                @pageNumber
            </button>
        }
        else if (i == currentPage - 2 || i == currentPage + 2)
        {
            <span class="pagination-ellipsis">...</span>
        }
    }
</div>
                
                <button type="button" class="pagination-btn" 
                        @onclick="NextPage"
                        disabled="@(currentPage >= paginatedEntries.TotalPages)">
                    Next ‚Üí
                </button>
            </div>
        </div>
    }
    </div>
</div>

@code {
    private PaginatedResult<JournalEntry> paginatedEntries = new();
    private List<JournalEntry> filteredEntries = new();
    private bool loading = true;
    private bool isSearching = false;
    private bool showAdvancedFilters = false;
    private bool isInSearchMode = false;
    private int currentPage = 1;
    private const int pageSize = 10;
    
    // Search parameters
    private SearchParameters searchParams = new();
    private string tagInput = "";
    private List<Mood> availableMoods = new();

    protected override async Task OnInitializedAsync()
    {
        await LoadEntries();
        await LoadAvailableMoods();
    }

    protected override async Task OnParametersSetAsync()
    {
        await LoadEntries();
    }

    private async Task LoadEntries()
    {
        if (AuthStateService.CurrentUser?.Id == null)
        {
            loading = false;
            paginatedEntries = new PaginatedResult<JournalEntry>
            {
                Items = new List<JournalEntry>(),
                TotalCount = 0,
                PageNumber = 1,
                PageSize = pageSize,
                TotalPages = 0
            };
            filteredEntries = new List<JournalEntry>();
            currentPage = 1;
            return;
        }

        loading = true;
        try
        {
            paginatedEntries = await JournalEntryService.GetEntriesByUserIdAsync(AuthStateService.CurrentUser.Id, currentPage, pageSize);
            filteredEntries = paginatedEntries.Items;
            StateHasChanged();
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error loading entries: {ex.Message}");
            ToastService.ShowError("Error", "Failed to load journal entries. Please try again.");
            paginatedEntries = new PaginatedResult<JournalEntry>
            {
                Items = new List<JournalEntry>(),
                TotalCount = 0,
                PageNumber = 1,
                PageSize = pageSize,
                TotalPages = 0
            };
            filteredEntries = new List<JournalEntry>();
            currentPage = 1;
            StateHasChanged();
        }
        finally
        {
            loading = false;
        }
    }

    private async Task GoToPage(int pageNumber)
{
    // Clamp the page number to valid range
    if (pageNumber < 1)
        pageNumber = 1;
    if (paginatedEntries.TotalPages > 0 && pageNumber > paginatedEntries.TotalPages)
        pageNumber = paginatedEntries.TotalPages;

    // Always update currentPage
    var pageChanged = currentPage != pageNumber;
    currentPage = pageNumber;

    // ALWAYS reload data when any page button is clicked (even if same page)
    // This eliminates Blazor change-detection flakiness
    if (isInSearchMode || HasActiveFilters())
    {
        await LoadSearchResults();
    }
    else
    {
        await LoadEntries();
    }

    // Force re-render in case Blazor doesn't detect the change
    StateHasChanged();
}

    private async Task PreviousPage()
{
    if (currentPage > 1)
    {
        currentPage--;
        if (isInSearchMode || HasActiveFilters())
        {
            await LoadSearchResults();
        }
        else
        {
            await LoadEntries();
        }
        StateHasChanged();
    }
}

private async Task NextPage()
{
    if (currentPage < paginatedEntries.TotalPages)
    {
        currentPage++;
        if (isInSearchMode || HasActiveFilters())
        {
            await LoadSearchResults();
        }
        else
        {
            await LoadEntries();
        }
        StateHasChanged();
    }
}

    private async Task LoadSearchResults()
    {
        if (AuthStateService.CurrentUser?.Id == null)
        {
            paginatedEntries = new PaginatedResult<JournalEntry>
            {
                Items = new List<JournalEntry>(),
                TotalCount = 0,
                PageNumber = 1,
                PageSize = pageSize,
                TotalPages = 0
            };
            filteredEntries = new List<JournalEntry>();
            currentPage = 1;
            return;
        }

        isSearching = true;
        try
        {
            PaginatedResult<JournalEntry> result;
            if (HasOnlyTextSearch())
            {
                result = await JournalEntryService.SearchEntriesAsync(
                    AuthStateService.CurrentUser.Id, 
                    searchParams.SearchTerm ?? "",
                    currentPage,
                    pageSize
                );
            }
            else
            {
                result = await JournalEntryService.SearchEntriesAdvancedAsync(
                    AuthStateService.CurrentUser.Id, 
                    searchParams,
                    currentPage,
                    pageSize
                );
            }

            paginatedEntries = result;
            filteredEntries = result.Items;
            StateHasChanged();
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error loading search results: {ex.Message}");
            ToastService.ShowError("Error", "Failed to load search results. Please try again.");
            paginatedEntries = new PaginatedResult<JournalEntry>
            {
                Items = new List<JournalEntry>(),
                TotalCount = 0,
                PageNumber = 1,
                PageSize = pageSize,
                TotalPages = 0
            };
            filteredEntries = new List<JournalEntry>();
            currentPage = 1;
            StateHasChanged();
        }
        finally
        {
            isSearching = false;
        }
    }

    private async Task LoadAvailableMoods()
    {
        availableMoods = MoodDefinitions.PredefinedMoods.Where(m => m.IsActive).ToList();
    }

    private async Task HandleSearchInput(ChangeEventArgs e)
    {
        searchParams.SearchTerm = e.Value?.ToString() ?? "";
    }

    private async Task HandleSearchKeyPress(KeyboardEventArgs e)
    {
        if (e.Key == "Enter")
        {
            await PerformAdvancedSearch();
        }
    }

    private async Task PerformAdvancedSearch()
    {
        if (AuthStateService.CurrentUser?.Id == null)
        {
            ToastService.ShowError("Error", "You must be logged in to search entries.");
            return;
        }

        currentPage = 1;
        isInSearchMode = true;
        await LoadSearchResults();
        
        if (!filteredEntries.Any())
        {
            ToastService.ShowInfo("No Results", "No entries found matching your search criteria");
        }
    }

    private async Task ClearAllFilters()
    {
        searchParams = new SearchParameters();
        tagInput = "";
        currentPage = 1;
        isInSearchMode = false;
        await LoadEntries();
    }

    private async Task GoBack()
    {
        await JS.InvokeVoidAsync("history.back");
    }

    private void ToggleFilters()
    {
        showAdvancedFilters = !showAdvancedFilters;
    }

    private bool HasActiveFilters()
    {
        return !string.IsNullOrWhiteSpace(searchParams.SearchTerm) ||
               searchParams.StartDate.HasValue ||
               searchParams.EndDate.HasValue ||
               (searchParams.MoodIds?.Any() == true) ||
               (searchParams.Tags?.Any() == true);
    }

    private bool HasOnlyTextSearch()
    {
        return !string.IsNullOrWhiteSpace(searchParams.SearchTerm) &&
               !searchParams.StartDate.HasValue &&
               !searchParams.EndDate.HasValue &&
               (searchParams.MoodIds?.Any() != true) &&
               (searchParams.Tags?.Any() != true);
    }

    private void ToggleMood(int moodId)
    {
        searchParams.MoodIds ??= new List<int>();
        
        if (searchParams.MoodIds.Contains(moodId))
        {
            searchParams.MoodIds.Remove(moodId);
            if (!searchParams.MoodIds.Any())
            {
                searchParams.MoodIds = null;
            }
        }
        else
        {
            searchParams.MoodIds.Add(moodId);
        }
    }

    private bool IsMoodSelected(int moodId)
    {
        return searchParams.MoodIds?.Contains(moodId) == true;
    }

    private async Task HandleTagKeyPress(KeyboardEventArgs e)
    {
        if (e.Key == "Enter")
        {
            await AddTags();
        }
    }

    private async Task AddTags()
    {
        if (string.IsNullOrWhiteSpace(tagInput))
            return;

        var tags = tagInput.Split(',', StringSplitOptions.RemoveEmptyEntries)
                           .Select(t => t.Trim())
                           .Where(t => !string.IsNullOrEmpty(t))
                           .ToList();

        if (tags.Any())
        {
            searchParams.Tags ??= new List<string>();
            foreach (var tag in tags)
            {
                if (!searchParams.Tags.Contains(tag, StringComparer.OrdinalIgnoreCase))
                {
                    searchParams.Tags.Add(tag);
                }
            }
            tagInput = "";
        }
    }

    private void RemoveTag(string tag)
    {
        if (searchParams.Tags != null)
        {
            searchParams.Tags.Remove(tag);
            if (!searchParams.Tags.Any())
            {
                searchParams.Tags = null;
            }
        }
    }

    private void CreateNewEntry()
    {
        NavigationManager.NavigateTo("/journal/new");
    }

    private void ViewEntry(int id)
    {
        NavigationManager.NavigateTo($"/journal/{id}");
    }

    private void EditEntry(int id)
    {
        NavigationManager.NavigateTo($"/journal/edit/{id}");
    }

    private async Task DeleteEntry(int id)
    {
        if (await JS.InvokeAsync<bool>("confirm", "Are you sure you want to delete this entry?"))
        {
            if (AuthStateService.CurrentUser?.Id != null)
            {
                try
                {
                    await JournalEntryService.DeleteEntryAsync(id, AuthStateService.CurrentUser.Id);
                    ToastService.ShowSuccess("Success", ToastMessages.EntryDeleted);
                    
                    if (isInSearchMode || HasActiveFilters())
                    {
                        await LoadSearchResults();
                        if (!filteredEntries.Any() && currentPage > 1)
                        {
                            currentPage--;
                            await LoadSearchResults();
                        }
                    }
                    else
                    {
                        await LoadEntries();
                        if (!filteredEntries.Any() && currentPage > 1)
                        {
                            currentPage--;
                            await LoadEntries();
                        }
                    }
                    
                    if (currentPage < 1)
                    {
                        currentPage = 1;
                    }
                }
                catch (Exception ex)
                {
                    Console.WriteLine($"Error deleting entry: {ex.Message}");
                    ToastService.ShowError("Error", "Failed to delete entry. Please try again.");
                }
            }
        }
    }

    private string GetContentPreview(string content)
    {
        if (string.IsNullOrEmpty(content))
            return "";

        var plainText = System.Text.RegularExpressions.Regex.Replace(content, @"[*#>`\-\[\]()]", "");
        plainText = System.Text.RegularExpressions.Regex.Replace(plainText, @"\s+", " ").Trim();
        
        return plainText.Length > 150 ? plainText.Substring(0, 147) + "..." : plainText;
    }

    private string GetMoodEmoji(string mood)
    {
        return mood.ToLower() switch
        {
            "happy" => "üòä",
            "sad" => "üò¢",
            "excited" => "üéâ",
            "anxious" => "üò∞",
            "grateful" => "üôè",
            "frustrated" => "üò§",
            "peaceful" => "üòå",
            _ => "üòê"
        };
    }
}